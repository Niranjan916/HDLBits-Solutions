_Goto HDLBits_ :point_right: [click here](https://hdlbits.01xz.net/wiki/Step_one)

# HDLBits-Solutions

## Problems _quick nav_ :small_red_triangle_down:

<details><summary>Getting Started</summary>
<p>
	
:white_check_mark: [Getting Started](https://github.com/Priyanshu-1012/HDLBits-Solutions#step-one-getting-started) 

:white_check_mark: [Output Zero](https://github.com/Priyanshu-1012/HDLBits-Solutions#zero-output-zero)

</p>
</details>



<details><summary>Verilog Language</summary>
<p>
	<details><summary>Basics</summary><p>
	
:white_check_mark: [Simple wire](https://github.com/Priyanshu-1012/HDLBits-Solutions#wire-simple-wire)
	
:white_check_mark: [Four Wires](https://github.com/Priyanshu-1012/HDLBits-Solutions#wire4-four-wires)
	
:white_check_mark: [Inverter](https://github.com/Priyanshu-1012/HDLBits-Solutions#notgate-inverter)
	
:white_check_mark: [AND gate](https://github.com/Priyanshu-1012/HDLBits-Solutions#andgate-and-gate)
	
:white_check_mark: [NOR gate](https://github.com/Priyanshu-1012/HDLBits-Solutions#norgate-nor-gate)
	
:white_check_mark: [XNOR gate](https://github.com/Priyanshu-1012/HDLBits-Solutions#xnorgate-xnor-gate)
	
:white_check_mark: [Declaring wires](https://github.com/Priyanshu-1012/HDLBits-Solutions#wire-decl-declaring-wires)
	
:white_check_mark: [7458 chip](https://github.com/Priyanshu-1012/HDLBits-Solutions#7458-7458-chip)

</p>
</details>

	
<details><summary>Vectors</summary>
<p>
	
:white_check_mark: [Vectors](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector0-vectors) 

:white_check_mark: [Vectors in more detail](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector1-vectors-in-more-detail)
		       
:white_check_mark: [Vector part select](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector2-vector-part-select)
		        
:white_check_mark: [Bitwise operators](https://github.com/Priyanshu-1012/HDLBits-Solutions#vectorgates-bitwise-operators)
		    
:white_check_mark: [Four-input gates](https://github.com/Priyanshu-1012/HDLBits-Solutions#gates4-4-input-gates)
		    
:white_check_mark: [Vector concantenation operator](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector3-vector-concatenation-operator)
		    
:white_check_mark: [Vector reversal 1](https://github.com/Priyanshu-1012/HDLBits-Solutions#vectorr-vector-reversal-1)
		    
:white_check_mark: [Replication operator](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector4-replication-operator)
		    
:white_check_mark: [More replication](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector5-more-replication)
</p>
</details>


<details><summary>Modules:Hierarchy</summary>
<p>

:white_check_mark: [Modules](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-modules)

:white_check_mark: [Connecting ports by position](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-pos-connecting-ports-by-position)

:white_check_mark: [Connecting ports by name](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-name-connecting-ports-by-name)

:white_check_mark: [Three module](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-shift-three-modules)

:white_check_mark: [Modules and vectors](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-shift8-modules-and-vectors)

:white_check_mark: [Adder 1](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-add-adder-1)
	
:white_check_mark: [Adder 2](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-fadd-adder-2)

:white_check_mark: [Carry-select adder](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-cseladd-carry-select-adder)
	
:white_check_mark: [Adder-subtractor](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-addsub-adder-subtractor)
	
</p>
</details>	
	
<details><summary>Procedures</summary>
<p>
	
:white_check_mark: [Always blocks(combinational)](https://github.com/Priyanshu-1012/HDLBits-Solutions#alwaysblock1-always-block-combinational)

:white_check_mark: [Always blocks(clocked)](https://github.com/Priyanshu-1012/HDLBits-Solutions#alwaysblock2-always-block-clocked)

:white_check_mark: [If statement](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-if-if-statement)
	
:white_check_mark: [If statement latches](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-if2-if-statement-latches)
	
:white_check_mark: [Case statement](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-case-case-statement)

:white_check_mark: [Priority encoder](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-case2-priority-encoder)

:white_check_mark: [Priority encoder with casez](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-casez-priority-encoder-with-casez)

:white_check_mark: [Avoiding latches](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-nolatches-avoiding-latches)
	
</p>
</details>

<details><summary>More verilog features</summary>
<p>	
	
	
:white_check_mark: [Conditional ternary operator](https://github.com/Priyanshu-1012/HDLBits-Solutions#conditional-conditional-ternary-operator)	

:white_check_mark: [Reduction operators](https://github.com/Priyanshu-1012/HDLBits-Solutions#reduction-reduction-operators)

:white_check_mark: [Reduction: Even wider gates](https://github.com/Priyanshu-1012/HDLBits-Solutions#gates100-reduction-even-wider-gates)

:white_check_mark: [Combinational for-loop: Vector reversal 2](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector100r-combinational-for-loop-vector-reversal-2)
	
:white_check_mark: [Combinational for-loop: 255-bit population count](https://github.com/Priyanshu-1012/HDLBits-Solutions#popcount255-combinational-for-loop-255-bit-population-count)	

:white_check_mark: [Generate for-loop: 100-bit binary adder 2](https://github.com/Priyanshu-1012/HDLBits-Solutions#adder100i-generate-for-loop-100-bit-binary-adder-2)
	
:white_check_mark: [Generate for-loop: 100-digit BCD adder](https://github.com/Priyanshu-1012/HDLBits-Solutions#bcdadd100-generate-for-loop-100-digit-bcd-adder)
	
	
</p>
</details>
	
</p>
</details>

<details><summary>Circuits</summary>
<p>

<details><summary>Combinational Logic</summary>
<p>

<details><summary>Basic Gates</summary>
<p>
	
:white_check_mark: [Wire](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4h-wire)
	
:white_check_mark: [GND](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4i-gnd)
	
:white_check_mark: [NOR](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4e-nor)
	
:white_check_mark: [Another gate](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4f-another-gate)
	
:white_check_mark: [Two gates](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4g-two-gates)
	
:white_check_mark: [More logic gates](https://github.com/Priyanshu-1012/HDLBits-Solutions#gates-more-logic-gates)
	
:white_check_mark: [7420 chip](https://github.com/Priyanshu-1012/HDLBits-Solutions#7420-7420-chip)
	
:white_check_mark: [Truth tables](https://github.com/Priyanshu-1012/HDLBits-Solutions#truthtable1-truth-tables)
	
:white_check_mark: [Two-bit equality](https://github.com/Priyanshu-1012/HDLBits-Solutions#mt2015-eq2-two-bit-equality)
	
:white_check_mark: [Simple circuit A](https://github.com/Priyanshu-1012/HDLBits-Solutions#mt2015-q4a-simple-circuit-a)
	
:white_check_mark: [Simple circuit B](https://github.com/Priyanshu-1012/HDLBits-Solutions#mt2015-q4b-simple-circuit-b)
	
:white_check_mark: [Combine circuits A and B](https://github.com/Priyanshu-1012/HDLBits-Solutions#mt2015-q4-combine-circuits-a-and-b)
	
:white_check_mark: [Ring or vibrate](https://github.com/Priyanshu-1012/HDLBits-Solutions#ringer-ring-or-vibrate)
	
:white_check_mark: [Thermostat](https://github.com/Priyanshu-1012/HDLBits-Solutions#thermostat)
	
:white_check_mark: [3-bit population count](https://github.com/Priyanshu-1012/HDLBits-Solutions#popcount3-3-bit-population-count)
	
:white_check_mark: [Gates and vectors](https://github.com/Priyanshu-1012/HDLBits-Solutions#gatesv-gates-and-vectors)
	
:white_check_mark: [Even longer vectors](https://github.com/Priyanshu-1012/HDLBits-Solutions#gatesv100-even-longer-vectors)
	
</p>
</details>	
	

<details><summary>Multiplexers</summary>
<p>

	
:white_check_mark: [2-to-1 multiplexer](https://github.com/Priyanshu-1012/HDLBits-Solutions#mux2to1-2-to-1-multiplexer)
	
:white_check_mark: [2-to-1 bus multiplexer](https://github.com/Priyanshu-1012/HDLBits-Solutions#mux2to1v-2-to-1-bus-multiplexer)
	
:white_check_mark: [9-to-1 multiplexer](https://github.com/Priyanshu-1012/HDLBits-Solutions#mux9to1-9-to-1-multiplexer)
	
:white_check_mark: [256-to-1 multiplexer](https://github.com/Priyanshu-1012/HDLBits-Solutions#mux256to1-256-to-1-multiplexer)
	
:white_check_mark: [256-to-1 4-bit multiplexer](https://github.com/Priyanshu-1012/HDLBits-Solutions#mux256to1v-256-to-1-4-bit-multiplexer)
	
</p>
</details>
	
<details><summary>Arithmetic Circuits</summary>
<p>

	
:white_check_mark: [Half adder](https://github.com/Priyanshu-1012/HDLBits-Solutions#hadd-half-adder)
	
:white_check_mark: [Full adder](https://github.com/Priyanshu-1012/HDLBits-Solutions#fadd-full-adder)
	
:white_check_mark: [3-bit binary adder](https://github.com/Priyanshu-1012/HDLBits-Solutions#adder3-3-bit-binary-adder)
	
:white_check_mark: [Adder](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4j-adder)
	
:white_check_mark: [Signed addition overflow](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsece241-2014-q1c-signed-addition-overflow)
	
:white_check_mark: [100-bit binary adder](https://github.com/Priyanshu-1012/HDLBits-Solutions#adder100-100-bit-binary-adder)
	
:white_check_mark: [4-bit BCD adder](https://github.com/Priyanshu-1012/HDLBits-Solutions#bcdadd4-4-bit-bcd-adder)
	
</p>
</details>	
	
<details><summary>Karnaugh Map to Circuit</summary>
<p>
	
	
:white_check_mark: [3-variable](https://github.com/Priyanshu-1012/HDLBits-Solutions#kmap1-3-variable)
	
:white_check_mark: [4-variable](https://github.com/Priyanshu-1012/HDLBits-Solutions#kmap2-4-variable)
	
:white_check_mark: [4-variable](https://github.com/Priyanshu-1012/HDLBits-Solutions#kmap3-4-variable)
	
:white_check_mark: [4-variable](https://github.com/Priyanshu-1012/HDLBits-Solutions#kmap4-4-variable)
	
:white_check_mark: [Minimum SOP and POS](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsece241-2013-q2-minimum-sop-and-pos)
	
:white_check_mark: [Karnaugh map](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q3-karnaugh-map)
	
:white_check_mark: [Karnaugh map](https://github.com/Priyanshu-1012/HDLBits-Solutions#exams2012-q1g-karnaugh-map)
	
:white_check_mark: [K-map imlimented with a multiplexer](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsece241-2014-q3-k-map-imlimented-with-a-multiplexer)
	
	
</p>
</details>

	
</p>
</details>

	

<details><summary>Sequential Logic</summary>
<p>



<details><summary>Latches and Flip-Flops</summary>
<p>


:white_check_mark: [D flip-flop](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#dff-d-flip-flop)

:white_check_mark: [D flip-flops](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#dff8-d-flip-flops)

:white_check_mark: [DFF with reset](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#dff8r-dff-with-reset)

:white_check_mark: [DFF with reset value](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#dff8p-dff-with-reset-value)

:white_check_mark: [DFF with asynchronous reset](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#dff8ar-dff-with-asynchronous-reset)

:white_check_mark: [DFF with byte enable](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#dff16e-dff-with-byte-enable)

:white_check_mark: [D Latch](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#examsm2014-q4a-d-latch)

:white_check_mark: [DFF](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#examsm2014-q4b-dff)

:white_check_mark: [DFF](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#examsm2014-q4c-dff)

:white_check_mark: [DFF+gate](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#examsm2014-q4d-dffgate)

:white_check_mark: [Mux and DFF](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#mt2015-muxdff-mux-and-dff)

:white_check_mark: [Mux and DFF](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#exams2014-q4a-mux-and-dff)

:white_check_mark: [DFFs and gates](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#examsece241-2014-q4-dffs-and-gates)

:white_check_mark: [Create circuit from truth table](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#examsece241-2013-q7-create-circuit-from-truth-table)

:white_check_mark: [Detect an edge](https://github.com/Priyanshu-1012/HDLBits-Solutions/blob/main/README.md#edgedetect-detect-an-edge)





------------1111111111111-----------111111111----------1111111111111-----------11111111-------------1111111111-------here!

</p>
</details>


</p>
</details>
	
	
	
</p>
</details>



## Step one [Getting started]

```verilog
module top_module( output one );

    assign one = 1;

endmodule
```
## Zero [Output zero]
```verilog
module top_module(
    output zero
);
assign zero=0;
endmodule
```
## Wire [Simple wire]
```verilog
module top_module( input in, output out );
assign out=in;
endmodule
```
## Wire4 [four wires]
```verilog
module top_module( 
    input a,b,c,
    output w,x,y,z );
assign w=a,x=b,y=b,z=c;
endmodule
```
## Notgate [Inverter]
```verilog
module top_module( input in, output out );
assign out=~in;
endmodule
```
## Andgate [AND gate]
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
assign out=a&b;
endmodule
```
## Norgate [NOR gate]
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
    assign out=~(a|b);
endmodule
```
## Xnorgate [XNOR gate]
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
    assign out= ~(a^b);
endmodule
```
## Wire decl [Declaring wires]
```verilog
`default_nettype none
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out,
    output out_n   ); 
wire andab,andcd,orout;
    assign andab=a&b,
           andcd=c&d, 
           orout=andab|andcd;
           
    assign out=orout, 
           out_n= ~(orout);
endmodule
```
## 7458 [7458 chip]
```verilog
module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
wire andp2ab,andp2cd,andp1abc,andp1def;

    assign andp2ab = p2a&p2b, 
           andp2cd = p2c&p2d, 
           p2y= andp2ab|andp2cd;
                     
    assign andp1abc= p1a&p1b&p1c, 
           andp1def= p1d&p1e&p1f,
           p1y= andp1abc|andp1def;

endmodule
```
## Vector0 [Vectors]
```verilog
module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); 
    
    assign  outv=vec[2:0];
    
    assign o2=vec[2], 
           o1=vec[1], 
           o0=vec[0]; 
endmodule
```
## Vector1 [Vectors in more detail]
```verilog
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi=in[15:8], 
           out_lo=in[7:0];
endmodule

```
## Vector2 [Vector part select]
```verilog
module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out[31:24] = in[7:0],
           out[23:16] = in[15:8],
           out[15:8] = in[23:16],
           out[7:0] = in[31:24];

endmodule
```
## Vectorgates [Bitwise operators]
```verilog
module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise[2:0]= a[2:0]|b[2:0],
           out_or_logical= a||b,
           out_not[5:3]=~b[2:0],
           out_not[2:0]=~a[2:0];
           
endmodule
```
## Gates4 [4-input gates]
```verilog
module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and=in[3]&in[2]&in[1]&in[0],
           out_or=in[3]|in[2]|in[1]|in[0],
           out_xor=in[3]^in[2]^in[1]^in[0];
endmodule
```
## Vector3 [Vector concatenation operator]
```verilog
module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    wire [31:0] com;
assign com[31:0]={a[4:0],b[4:0],c[4:0],d[4:0],e[4:0],f[4:0],2'b11};
    assign z[7:0]= com[7:0];
    assign y[7:0]= com[15:8];
    assign x[7:0]= com[23:16];
    assign w[7:0]= com[31:24];

endmodule
```
## Vectorr [Vector reversal 1]
```verilog
module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out[7:0]={in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
```
method2 (using loop)
```verilog
module top_module( 
    input [7:0] in,
    output [7:0] out
);
  always @(*) begin	
		for (int i=0; i<8; i++)	
			out[i] = in[8-i-1];
	end
endmodule
```
method3 (using generate for-loop)
```verilog
module top_module( 
    input [7:0] in,
    output [7:0] out
);
  generate
		genvar i;
      for (i=0; i<8; i = i+1) begin: rev
			assign out[i] = in[8-i-1];
		end
	endgenerate
endmodule
```
## Vector4 [Replication operator]
```verilog
module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out={{24{in[7]}}, in[7:0]};

endmodule
```
## Vector5 [More replication]
```verilog
module top_module (
    input a, b, c, d, e,
    output [24:0] out );
    
assign out=~{{5{a}},{5{b}},{5{c}},{5{d}},{5{e}}}^{5{a,b,c,d,e}};
    
endmodule
```
## Module [Modules]
```verilog
module top_module ( input a, input b, output out );
    mod_a inst1 (.in1(a), .in2(b), .out(out));
   
    
endmodule
```
## Module pos [Connecting ports by position]
```verilog
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a inst1(out1,out2,a,b,c,d);
endmodule
```
## Module name [Connecting ports by name]
```verilog
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a inst1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2) );
endmodule
```
## Module shift [Three modules]
```verilog
module top_module ( input clk, input d, output q );
    wire q1,q2;
    my_dff inst1(.clk(clk), .d(d), .q(q1));
    my_dff inst2(.clk(clk), .d(q1), .q(q2));
    my_dff inst3(.clk(clk), .d(q2), .q(q));
endmodule
```
## Module shift8 [Modules and vectors]
```verilog
module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    wire [7:0]q1,q2,q3;
    
    my_dff8 inst1(.clk(clk), .d(d), .q(q1));
    my_dff8 inst2(.clk(clk), .d(q1), .q(q2));
    my_dff8 inst3(.clk(clk), .d(q2), .q(q3));
    
    always @(*)    //this is for combinational block
		case(sel)
			2'h0: q = d;
			2'h1: q = q1;
			2'h2: q = q2;
			2'h3: q = q3;
		endcase

endmodule
```
## Module add [Adder-1]
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire c1,c2;

    add16 inst1(.a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]), .cout(c1));
    add16 inst2(.a(a[31:16]), .b(b[31:16]), .cin(c1), .sum(sum[31:16]), .cout(c2));

endmodule
```
## Module fadd [Adder-2]
```verilog
module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire c,c2;
    
    add16 inst1(.a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]),  .cout(c));
    add16 inst2(.a(a[31:16]), .b(b[31:16]), .cin(c), .sum(sum[31:16]),  .cout(c2));
endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

 assign sum = a ^ b ^ cin;
 assign cout = a&b | a&cin | b&cin;
 
endmodule
```
## Module cseladd [Carry-select adder]
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0]s2,s3,c2,c3,sel;
    
    add16 inst1(.a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]), .cout(sel));
    add16 inst2(.a(a[31:16]), .b(b[31:16]), .cin(1'b0), .sum(s2), .cout(c2));
    add16 inst3(.a(a[31:16]), .b(b[31:16]), .cin(1'b1), .sum(s3), .cout(c3));
    
    always @(*)    
		case(sel)
           1'b0  : sum[31:16] = s2;
           1'b1  : sum[31:16] = s3;
		endcase

endmodule
```
## Module addsub [Adder-subtractor]
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0]c,c2;
    wire [31:0]xorout,subin;
    
    assign subin={32{sub}};   //making sub 32 bit so that we can XOR it with inp 'b'.
    assign xorout=b^subin;
    
    add16 inst1(.a(a[15:0]), .b(xorout[15:0]), .cin(sub), .cout(c), .sum(sum[15:0]));
    add16 inst2(.a(a[31:16]), .b(xorout[31:16]), .cin(c), .cout(c2), .sum(sum[31:16]));

endmodule
```
method2 (XOR as programmable inverter)

![image](https://user-images.githubusercontent.com/39450902/209582275-f3619c07-8380-4e14-bb1d-aa5c209ef690.png)


```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0]c,c2;
    wire [31:0]xorout;
    
    always @(*)                      //XOR gate can also be viewed as a programmable inverter, 
        case(sub)
            0: xorout = b;           //where one input controls whether the other should be inverted
            1: xorout = ~b;
        endcase
    add16 inst1(.a(a[15:0]), .b(xorout[15:0]), .cin(sub), .cout(c), .sum(sum[15:0]));
    add16 inst2(.a(a[31:16]), .b(xorout[31:16]), .cin(c), .cout(c2), .sum(sum[31:16]));

endmodule
```
## Alwaysblock1 [Always block (combinational)]
```verilog
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
assign out_assign = a & b;
always @(*) out_alwaysblock = a & b;
endmodule
```
## Alwaysblock2 [Always block (clocked)]
```verilog
// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
assign out_assign = a ^ b;
always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
endmodule
```
## Always if [If statement]
```verilog

module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign= sel_b2 ? (sel_b1 ? b : a) : a;
    
    always @(*) begin
        if(sel_b1 && sel_b2) begin
            out_always=b;
        end
        else begin
            out_always=a;
        end
    end
    
endmodule

```
## Always if2 [If statement latches]
```verilog
module top_module (
    input      cpu_overheated,
    output reg shut_off_computer,
    input      arrived,
    input      gas_tank_empty,
    output reg keep_driving  ); //

    always @(*) begin
        shut_off_computer=cpu_overheated; 
    end

    always @(*) begin
        if (~arrived && ~gas_tank_empty) begin
           keep_driving = 1;
          end
         else begin
          keep_driving = 0;
        end
    end

endmodule
```
## Always case [Case statement]
```verilog
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000 : out=data0;
            3'b001 : out=data1;
            3'b010 : out=data2;
            3'b011 : out=data3;
            3'b100 : out=data4;
            3'b101 : out=data5;
            3'b110 : out=0;
            3'b111 : out=0;
            
        endcase
    end

endmodule
```
## Always case2 [Priority encoder]
```verilog
// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    always @(*)begin
        
        if(in[0]==1)
            pos=0;
        else if(in[1]==1)
            pos=1;
        else if(in[2]==1)
            pos=2; 
        else if(in[3]==1)
            pos=3;
        else pos=0;
    end
endmodule
```
method2 (using loop)
```verilog
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    integer i;
       always @(*) begin
           pos=2'b00;
           for(i=3;i>=0;i=i-1)
            if(in[i]==1)
                pos=i;
       end
endmodule
```
## Always casez [Priority encoder with casez]
```verilog
// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        casez(in[7:0])
       8'bzzzzzzz1 : pos=0;
       8'bzzzzzz1z : pos=1;
       8'bzzzzz1zz : pos=2;
       8'bzzzz1zzz : pos=3;
       8'bzzz1zzzz : pos=4;
       8'bzz1zzzzz : pos=5;
       8'bz1zzzzzz : pos=6;
       8'b1zzzzzzz : pos=7;
       default : pos=0;
        endcase
    end
endmodule

```
## Always nolatches [Avoiding latches]
```verilog
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
   
   always @* begin
    up=0;down=0;right=0;left=0;
      case(scancode)
        16'he06b : left = 1;
        16'he072 : down = 1;
	16'he074 : right = 1;
	16'he075 : up = 1;
      endcase
   end
endmodule
```
## Conditional [Conditional ternary operator]
```verilog
module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//
    wire [7:0]abmin,cdmin;

    assign abmin = a>b ? b : a;
    assign cdmin = c>d ? d : c;
    assign min = abmin>cdmin ? cdmin : abmin;
endmodule
```
## Reduction [Reduction operators]
```verilog
module top_module (
    input [7:0] in,
    output parity); 
    assign parity= ^in[7:0];
endmodule
```
## Gates100 [Reduction: Even wider gates]

```verilog
module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = &in[99:0];
    assign out_or = |in[99:0];
    assign out_xor = ^in[99:0];
endmodule
```
## Vector100r [Combinational for-loop: Vector reversal 2]

```verilog
module top_module( 
    input [99:0] in,
    output [99:0] out
);
    integer i;
always @* begin
    for(i=99;i>=0;i=i-1) 
        out[99-i]=in[i];
    end
endmodule
```
## Popcount255 [Combinational for-loop: 255-bit population count]

```verilog
module top_module( 
    input [254:0] in,
    output [7:0] out );
  integer i;
    always @* begin
     out=0;
        for(i=254;i>=0;i=i-1)
         if(in[i]==1) 
           out=out+1;
            else ;
    end
endmodule
```
## Adder100i [Generate for-loop: 100-bit binary adder 2]

```verilog
module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    assign cout[0]= a[0]&b[0] | b[0]&cin | a[0]&cin;
    assign sum[0]= a[0]^b[0]^cin;
   
    integer i;
    always @* begin
        for(i=1;i<100;i++)begin
            sum[i]= a[i]^b[i]^cout[i-1];
            cout[i]= a[i]&b[i] | b[i]&cout[i-1] | a[i]&cout[i-1];
        end
    end
endmodule
```
## Bcdadd100 [Generate for-loop: 100-digit BCD adder]

```verilog
module top_module( 
    input [399:0] a, b,
    input cin,
    output cout,
    output [399:0] sum );
    
    wire [99:0]couts;
  
    generate 
        genvar i;
        for (i=0; i<100; i=i+1) begin: bcdadd
        if(i==0) begin
            bcd_fadd inst(a[3:0], b[3:0], cin, couts[0],sum[3:0]);
	    end
        else begin
            bcd_fadd insta(a[(4*i+3):(4*i)], b[(4*i+3):(4*i)], couts[i-1],couts[i],sum[(4*i+3):(4*i)]); 
	    end
        end
    assign cout=couts[99];
    endgenerate
endmodule
```
## Exams/m2014 q4h [Wire]

```verilog
module top_module (
    input in,
    output out);
    
assign out=in;

endmodule
```
## Exams/m2014 q4i [GND]

```verilog
module top_module (
    output out);
    
assign out=0;

endmodule
```
##  Exams/m2014 q4e [NOR]

```verilog
module top_module (
    input in1,
    input in2,
    output out);
    
    assign out=~(in1|in2);
    
endmodule
```
## Exams/m2014 q4f [Another gate]

```verilog
module top_module (
    input in1,
    input in2,
    output out);
    
assign out=in1&~in2;

endmodule
```
## Exams/m2014 q4g [Two gates]

```verilog
module top_module (
    input in1,
    input in2,
    input in3,
    output out);

    wire xnorout;
    
    assign xnorout = ~(in1 ^ in2);
    assign out = xnorout ^ in3;
    
endmodule
```
## Gates [More logic gates]

```verilog
module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and= a & b;
	assign out_or= a | b;
	assign out_xor= a ^ b;
    assign out_nand= ~(a & b);
    assign out_nor= ~(a | b);
    assign out_xnor= ~(a ^ b);
	assign out_anotb= a & ~b;

    
endmodule
```
## 7420 [7420 chip]

```verilog
module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule
```
## Truthtable1 [Truth tables]

```verilog
module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
 
    assign f=(~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);
    
endmodule
```
## Mt2015 eq2 [Two-bit equality]

```verilog
module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @* begin
        if(A==B)
            z=1;
    else z=0;
    end
endmodule
```
## Mt2015 q4a [Simple circuit A]

```verilog
module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule
```
## Mt2015 q4b [Simple circuit B]

```verilog
module top_module ( input x, input y, output z );
    assign z = ~(x ^ y);
endmodule
```
## Mt2015 q4 [Combine circuits A and B]

```verilog
module top_module (input x, input y, output z);
wire z1,z2,z3,z4,zor,zand;
    moda inst1(x,y,z1);
    moda inst2(x,y,z2);
    modb inst3(x,y,z3);
    modb inst4(x,y,z4);
    
    assign zor= z1 | z2;
    assign zand = z3 & z4;
    assign z= zor ^ zand;
    
endmodule
   module moda (input x, input y, output z);
    assign z = (x^y) & x;
endmodule

    module modb ( input x, input y, output z );
    assign z = ~(x ^ y);
endmodule
```
## Ringer [Ring or vibrate]

```verilog
module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
	assign ringer = ring & ~vibrate_mode;
    assign motor = ring & vibrate_mode;
endmodule
```
## Thermostat

```verilog
module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 
    assign heater = mode & too_cold ;
    assign aircon = ~mode & too_hot ;
    assign fan = aircon | heater | fan_on;
        
endmodule
```
## Popcount3 [3-bit population count]

```verilog
module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    always @* begin
        out=0;
        for(i=2;i>=0;i=i-1)
            if(in[i]==1)
                out=out+1;
        else ;
    end
endmodule
```
## Gatesv [Gates and vectors]

```verilog
module top_module( 
    input [3:0] in,
    output [2:0] out_both,
    output [3:1] out_any,
    output [3:0] out_different );
    
    assign out_both = in[2:0] & in[3:1] ;
    assign out_any = in[3:1] | in[2:0];
    assign out_different = in[3:0] ^ {in[0], in[3:1]};
endmodule
```
## Gatesv100 [Even longer vectors]

```verilog
module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[98:0] & in[99:1];
    assign out_any = in[99:1] | in[98:0];
    assign out_different = in[99:0] ^ {in[0], in[99:1]};
endmodule
```
## Mux2to1 [2-to-1 multiplexer]

```verilog
module top_module( 
    input a, b, sel,
    output out ); 
assign out= sel ? b : a;
endmodule
```
## Mux2to1v [2-to-1 bus multiplexer]
```verilog
module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
assign out= sel ? b : a;
endmodule
```
## Mux9to1 [9-to-1 multiplexer]
```verilog
module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    always @* begin
        case(sel)
            4'b0000   : out = a ;
            4'b0001    : out = b;
            4'b0010   : out = c;
            4'b0011   : out = d;
            4'b0100    : out = e;
            4'b0101    : out = f;
            4'b0110    : out = g;
            4'b0111   : out = h;
            4'b1000    : out = i;
            default : out = {16{1'b1}};
        endcase
    end
        
endmodule
```
## Mux256to1 [256-to-1 multiplexer]

```verilog
module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out= in[sel];
    
endmodule
```
## Mux256to1v [256-to-1 4-bit multiplexer]

```verilog
module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

  assign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};
endmodule
```
## Hadd [Half adder]

```verilog
module top_module( 
    input a, b,
    output cout, sum );
    
	assign sum = a ^ b;
	assign cout= a & b;
endmodule
```

## Fadd [Full adder]

```verilog
module top_module( 
    input a, b, cin,
    output cout, sum );

    assign sum = a ^ b ^ cin;
    assign cout = a&b | b&cin | cin&a;
endmodule
```

## Adder3 [3-bit binary adder]

```verilog
module top_module( 
    input [2:0] a, b,
    input cin,
    output [2:0] cout,
    output [2:0] sum );

    fadd inst1(a[0],b[0],cin,cout[0],sum[0]);
    fadd inst2(a[1],b[1],cout[0],cout[1],sum[1]);
    fadd inst3(a[2],b[2],cout[1],cout[2],sum[2]);
    
endmodule

module fadd( 
    input a, b, cin,
    output cout, sum );

    assign sum = a ^ b ^ cin;
    assign cout = a&b | b&cin | cin&a;
endmodule
```
## Exams/m2014 q4j [Adder]

```verilog
module top_module (
    input [3:0] x,
    input [3:0] y, 
    output [4:0] sum);
    
    wire [2:0]cout;
    
    fadd inst1(x[0],y[0],1'b0,cout[0],sum[0]);
    fadd inst2(x[1],y[1],cout[0],cout[1],sum[1]);
    fadd inst3(x[2],y[2],cout[1],cout[2],sum[2]);
    fadd inst4(x[3],y[3],cout[2],sum[4],sum[3]);
    
endmodule

module fadd( 
    input a, b, cin,
    output cout, sum );

    assign sum = a ^ b ^ cin;
    assign cout = a&b | b&cin | cin&a;
endmodule
```

## Exams/ece241 2014 q1c [Signed addition overflow]

```verilog
module top_module (
    input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); //
 
     assign s = a+b;
    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);

endmodule
```
## Adder100 [100-bit binary adder]

```verilog
module top_module( 
    input [99:0] a, b,
    input cin,
    output cout,
    output [99:0] sum ); 
    
 reg [100:0]temp;

	assign temp = a + b + cin; 
    assign sum[99:0]=temp[99:0];
    assign cout=temp[100]; 
    
endmodule
```
## Bcdadd4 [4-bit BCD adder]

```verilog
module top_module ( 
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );
    
    wire c1,c2,c3;
    
    bcd_fadd inst1(a[3:0], b[3:0], cin, c1, sum[3:0]);
    bcd_fadd inst2(a[7:4], b[7:4], c1, c2, sum[7:4]);
    bcd_fadd inst3(a[11:8], b[11:8], c2, c3, sum[11:8]);
    bcd_fadd inst4(a[15:12], b[15:12], c3, cout, sum[15:12]);
    
endmodule
```

##  kmap1 [3-variable]

![image](https://user-images.githubusercontent.com/39450902/209859609-1975e9c1-90e7-4955-9b63-d5df4bf0af74.png)

```verilog
module top_module(
    input a,
    input b,
    input c,
    output out  ); 

    assign out = b | c | a;
    
endmodule
```

## kmap2 [4-variable]

![image](https://user-images.githubusercontent.com/39450902/209860400-f1a5230f-9d11-409f-a68d-e9783b29c1bf.png)

```verilog
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
assign out = (~a&~d) | (~b&~c) | (~a&b&c) | (a&c&d);
    
endmodule
```
## kmap3 [4-variable]
  
![image](https://user-images.githubusercontent.com/39450902/209860969-73858b5b-62bd-4164-9578-e7c1058cbab5.png)

```verilog
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 

    assign out = a | (~b&c) | (b&~c&~d);
    
endmodule
```

## kmap4 [4-variable]

```verilog
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out  ); 
    
    assign out = a ^ b ^ c ^ d;    //kmap simplfies to XOR
    
endmodule
```
## Exams/ece241 2013 q2 [Minimum SOP and POS]

```verilog
module top_module (
    input a,
    input b,
    input c,
    input d,
    output out_sop,
    output out_pos
); 

    assign out_sop = (c&d) | (c&~a&~b) ;
    assign out_pos = c & (d|~b) & (d|~a) ;
endmodule
```

## Exams/m2014 q3 [Karnaugh map]

```verilog
module top_module (
    input [4:1] x, 
    output f );
    assign f = (x[3]&~x[1]) | (x[3]&x[4]) | (x[2]&x[4]) | (x[1]&~x[3]&~x[4]) | (x[1]&~x[2]&x[3]) | (~x[1]&~x[2]&~x[4]);
endmodule
```

## Exams/2012 q1g [Karnaugh map]

```verilog
module top_module (
    input [4:1] x,
    output f
); 
    assign f = (~x[1]&x[3]) | (x[2]&x[3]&x[4]) | (~x[2]&~x[4]);
endmodule
```
## Exams/ece241 2014 q3 [K-map imlimented with a multiplexer]

```verilog
module top_module (
    input c,
    input d,
    output [3:0] mux_in
); 
    //solving the kmap give the expression 
    // f= (ab'd') + (abcd) + (a'b'(c+d))
    // a and b are select variables
    
    assign mux_in[0]= c ? 1 : (d ? 1 : 0)  ;    // c OR d
    assign mux_in[1]= 0;			// zero
    assign mux_in[2]= d ? 0 : 1;		// not D
    assign mux_in[3]= c ? (d ? 1 : 0) : 0;      // c AND D
    
endmodule
```

## Dff [D flip-flop]

```verilog
module top_module (
    input clk,    // Clocks are used in sequential circuits
    input d,
    output reg q );//

    always @(posedge clk) begin // Use a clocked always block
   		q <= d; //   copy d to q at every positive edge of clk
    end 

endmodule
```

## Dff8 [D flip-flops]

```verilog
module top_module (
    input clk,
    input [7:0] d,
    output [7:0] q
);
    always @(posedge clk) begin
        q <= d;
    end
endmodule
```

## Dff8r [DFF with reset]

```verilog
module top_module (
    input clk,
    input reset,            // Synchronous reset
    input [7:0] d,
    output [7:0] q
);
    always @(posedge clk) begin
        if(reset==0)
            q <= d;
        else q <= 0;
    end
endmodule
```

## Dff8p [DFF with reset value]

```verilog
module top_module (
    input clk,
    input reset,
    input [7:0] d,
    output [7:0] q
);
    always @(negedge clk) begin
        if(reset==0)
            q <= d;
        else q <= 'h34;
    end
endmodule
```

## Dff8ar [DFF with asynchronous reset]

```verilog
module top_module (
    input clk,
    input areset,   // active high asynchronous reset
    input [7:0] d,
    output [7:0] q
);

    always @(posedge clk or posedge areset) begin
        if(areset==1)
            q <= 0;
        else q <= d;
    end
endmodule
```

## Dff16e [DFF with byte enable]

```verilog
module top_module (
    input clk,
    input resetn,
    input [1:0] byteena,
    input [15:0] d,
    output [15:0] q
);
    always @(posedge clk) begin
        if(resetn==0)
            q <= 0;
        else begin
            if(byteena[1]==1)
                q[15:8] <= d[15:8];
            else ;
            
            if(byteena[0]==1)
                q[7:0] <= d[7:0];
            else ;
        end
    end

endmodule
```

## Exams/m2014 q4a [D Latch]

```verilog
module top_module (
    input d, 
    input ena,
    output q);

    always @(*) begin
        if(ena==1)
            q <= d;
   		 else ;
    end
endmodule
```

## Exams/m2014 q4b [DFF]

```verilog
module top_module (
    input clk,
    input d, 
    input ar,   // asynchronous reset
    output q);

    always @(posedge clk or posedge ar) begin
        if(ar==1)
            q <= 0;
        else
            q <= d;
    end
endmodule
```

## Exams/m2014 q4c [DFF]

```verilog
module top_module (
    input clk,
    input d, 
    input r,   // synchronous reset
    output q);

    always @(posedge clk) begin
        if(r==1)
            q <= 0;
        else q <= d;
    end
endmodule
```

## Exams/m2014 q4d [DFF+gate]

```verilog
module top_module (
    input clk,
    input in, 
    output out);
    
    wire d;
    assign d = out ^ in;
    always @(posedge clk) begin
        out <= d;
    end
        
endmodule
```

## Mt2015 muxdff [Mux and DFF]

```verilog
module top_module (
	input clk,
	input L,
	input r_in,
	input q_in,
	output reg Q);

    wire d;
    
    assign d= L ? r_in : q_in;
    
    always @(posedge clk) begin
        Q <= d; end
endmodule
```
## Exams/2014 q4a [Mux and DFF]

```verilog
module top_module (
    input clk,
    input w, R, E, L,
    output Q
);

    wire w1,d;
    
    assign w1= E ? w : Q;
    assign d = L ? R : w1;
    
    always @(posedge clk) 
        Q <= d;
        
endmodule
```
## Exams/ece241 2014 q4 [DFFs and gates]

```verilog
module top_module (
    input clk,
    input x,
    output z
); 

    wire d1,d2,d3;
    reg q1=0, q2=0, q3=0;
    
    assign d1= q1 ^ x;
    assign d2= ~q2 & x;
    assign d3= ~q3 | x;
    
    d_ff inst1(d1,clk,q1);
    d_ff inst2(d2,clk,q2);
    d_ff inst3(d3,clk,q3);
 
    assign z = ~(q1 | q2 | q3); 
        
endmodule

module d_ff (input d,
    input clk,
    output reg q);
    always@(posedge clk) begin
        q <= d;
    end
endmodule
```
or... it can be done like this...(but i prefer the first one)

```verilog
module top_module (
    input clk,
    input x,
    output z
); 

    wire d1,d2,d3;
    reg q1=0, q2=0, q3=0;
    
    assign d1= q1 ^ x;
    assign d2= ~q2 & x;
    assign d3= ~q3 | x;

    always @(posedge clk) begin
        q1 <= d1;
        q2 <= d2;
        q3 <= d3; end
 
    assign z = ~(q1 | q2 | q3); 
        
endmodule
```

## Exams/ece241 2013 q7 [Create circuit from truth table]

```verilog
module top_module (
    input clk,
    input j,
    input k,
    output Q); 

    always @(posedge clk) begin
        if(j==0 && k==0)
            Q <= Q;
        
        else if (j==0 && k==1)
            Q <= 0;
        
        else if(j==1 && k==0)
            Q <= 1;
        
        else  Q <= ~Q;
    end
        
 endmodule
```

## Edgedetect [Detect an edge]

```verilog

```

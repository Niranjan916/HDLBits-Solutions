_Goto HDLBits_ :point_right: [click here](https://hdlbits.01xz.net/wiki/Step_one)

# HDLBits-Solutions

## Problems _quick nav_ :small_red_triangle_down:

<details><summary>Getting Started</summary>
<p>
	
:white_check_mark: [Getting Started](https://github.com/Priyanshu-1012/HDLBits-Solutions#step-one-getting-started) 

:white_check_mark: [Output Zero](https://github.com/Priyanshu-1012/HDLBits-Solutions#zero-output-zero)

</p>
</details>



<details><summary>Verilog Language</summary>
<p>
	<details><summary>Basics</summary><p>
	
:white_check_mark: [Simple wire](https://github.com/Priyanshu-1012/HDLBits-Solutions#wire-simple-wire)
	
:white_check_mark: [Four Wires](https://github.com/Priyanshu-1012/HDLBits-Solutions#wire4-four-wires)
	
:white_check_mark: [Inverter](https://github.com/Priyanshu-1012/HDLBits-Solutions#notgate-inverter)
	
:white_check_mark: [AND gate](https://github.com/Priyanshu-1012/HDLBits-Solutions#andgate-and-gate)
	
:white_check_mark: [NOR gate](https://github.com/Priyanshu-1012/HDLBits-Solutions#norgate-nor-gate)
	
:white_check_mark: [XNOR gate](https://github.com/Priyanshu-1012/HDLBits-Solutions#xnorgate-xnor-gate)
	
:white_check_mark: [Declaring wires](https://github.com/Priyanshu-1012/HDLBits-Solutions#wire-decl-declaring-wires)
	
:white_check_mark: [7458 chip](https://github.com/Priyanshu-1012/HDLBits-Solutions#7458-7458-chip)

</p>
</details>

	
<details><summary>Vectors</summary>
<p>
	
:white_check_mark: [Vectors](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector0-vectors) 

:white_check_mark: [Vectors in more detail](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector1-vectors-in-more-detail)
		       
:white_check_mark: [Vector part select](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector2-vector-part-select)
		        
:white_check_mark: [Bitwise operators](https://github.com/Priyanshu-1012/HDLBits-Solutions#vectorgates-bitwise-operators)
		    
:white_check_mark: [Four-input gates](https://github.com/Priyanshu-1012/HDLBits-Solutions#gates4-4-input-gates)
		    
:white_check_mark: [Vector concantenation operator](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector3-vector-concatenation-operator)
		    
:white_check_mark: [Vector reversal 1](https://github.com/Priyanshu-1012/HDLBits-Solutions#vectorr-vector-reversal-1)
		    
:white_check_mark: [Replication operator](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector4-replication-operator)
		    
:white_check_mark: [More replication](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector5-more-replication)
</p>
</details>


<details><summary>Modules:Hierarchy</summary>
<p>

:white_check_mark: [Modules](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-modules)

:white_check_mark: [Connecting ports by position](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-pos-connecting-ports-by-position)

:white_check_mark: [Connecting ports by name](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-name-connecting-ports-by-name)

:white_check_mark: [Three module](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-shift-three-modules)

:white_check_mark: [Modules and vectors](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-shift8-modules-and-vectors)

:white_check_mark: [Adder 1](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-add-adder-1)
	
:white_check_mark: [Adder 2](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-fadd-adder-2)

:white_check_mark: [Carry-select adder](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-cseladd-carry-select-adder)
	
:white_check_mark: [Adder-subtractor](https://github.com/Priyanshu-1012/HDLBits-Solutions#module-addsub-adder-subtractor)
	
</p>
</details>	
	
<details><summary>Procedures</summary>
<p>
	
:white_check_mark: [Always blocks(combinational)](https://github.com/Priyanshu-1012/HDLBits-Solutions#alwaysblock1-always-block-combinational)

:white_check_mark: [Always blocks(clocked)](https://github.com/Priyanshu-1012/HDLBits-Solutions#alwaysblock2-always-block-clocked)

:white_check_mark: [If statement](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-if-if-statement)
	
:white_check_mark: [If statement latches](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-if2-if-statement-latches)
	
:white_check_mark: [Case statement](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-case-case-statement)

:white_check_mark: [Priority encoder](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-case2-priority-encoder)

:white_check_mark: [Priority encoder with casez](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-casez-priority-encoder-with-casez)

:white_check_mark: [Avoiding latches](https://github.com/Priyanshu-1012/HDLBits-Solutions#always-nolatches-avoiding-latches)
	
</p>
</details>

<details><summary>More verilog features</summary>
<p>	
	
	
:white_check_mark: [Conditional ternary operator](https://github.com/Priyanshu-1012/HDLBits-Solutions#conditional-conditional-ternary-operator)	

:white_check_mark: [Reduction operators](https://github.com/Priyanshu-1012/HDLBits-Solutions#reduction-reduction-operators)

:white_check_mark: [Reduction: Even wider gates](https://github.com/Priyanshu-1012/HDLBits-Solutions#gates100-reduction-even-wider-gates)

:white_check_mark: [Combinational for-loop: Vector reversal 2](https://github.com/Priyanshu-1012/HDLBits-Solutions#vector100r-combinational-for-loop-vector-reversal-2)
	
:white_check_mark: [Combinational for-loop: 255-bit population count](https://github.com/Priyanshu-1012/HDLBits-Solutions#popcount255-combinational-for-loop-255-bit-population-count)	

:white_check_mark: [Generate for-loop: 100-bit binary adder 2](https://github.com/Priyanshu-1012/HDLBits-Solutions#adder100i-generate-for-loop-100-bit-binary-adder-2)
	
:white_check_mark: [Generate for-loop: 100-digit BCD adder](https://github.com/Priyanshu-1012/HDLBits-Solutions#bcdadd100-generate-for-loop-100-digit-bcd-adder)
	
	
</p>
</details>
	
</p>
</details>

<details><summary>Circuits</summary>
<p>

<details><summary>Combinational Logic</summary>
<p>

<details><summary>Basic Gates</summary>
<p>
	
:white_check_mark: [Wire](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4h-wire)
	
:white_check_mark: [GND](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4i-gnd)
	
:white_check_mark: [NOR](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4e-nor)
	
:white_check_mark: [Another gate](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4f-another-gate)
	
:white_check_mark: [Two gates](https://github.com/Priyanshu-1012/HDLBits-Solutions#examsm2014-q4g-two-gates)
	
:white_check_mark: [More logic gates](https://github.com/Priyanshu-1012/HDLBits-Solutions#gates-more-logic-gates)
	
:white_check_mark: [7420 chip](https://github.com/Priyanshu-1012/HDLBits-Solutions#7420-7420-chip)
	
:white_check_mark: [Truth tables](https://github.com/Priyanshu-1012/HDLBits-Solutions#truthtable1-truth-tables)
	
:white_check_mark: [Two-bit equality](https://github.com/Priyanshu-1012/HDLBits-Solutions#mt2015-eq2-two-bit-equality)
	
:white_check_mark: [Simple circuit A](https://github.com/Priyanshu-1012/HDLBits-Solutions#mt2015-q4a-simple-circuit-a)
	
:white_check_mark: [Simple circuit B](https://github.com/Priyanshu-1012/HDLBits-Solutions#mt2015-q4b-simple-circuit-b)
	
:white_check_mark: [Combine circuits A and B](https://github.com/Priyanshu-1012/HDLBits-Solutions#mt2015-q4-combine-circuits-a-and-b)
	
:white_check_mark: [Ring or vibrate](https://github.com/Priyanshu-1012/HDLBits-Solutions#ringer-ring-or-vibrate)
	
:white_check_mark: [Thermostat](https://github.com/Priyanshu-1012/HDLBits-Solutions#thermostat)
	
:white_check_mark: [3-bit population count](https://github.com/Priyanshu-1012/HDLBits-Solutions#popcount3-3-bit-population-count)
	
:white_check_mark: [Gates and vectors](https://github.com/Priyanshu-1012/HDLBits-Solutions#gatesv-gates-and-vectors)
	
:white_check_mark: [Even longer vectors](https://github.com/Priyanshu-1012/HDLBits-Solutions#gatesv100-even-longer-vectors)
	
</p>
</details>	
	

<details><summary>Multiplexers</summary>
<p>
	
--------1----------1---------1--------1----------1--------------1------------1-----------1--------1---------!here	
</p>
</details>
	
	
	
</p>
</details>

	
	
	
</p>
</details>



## Step one [Getting started]

```verilog
module top_module( output one );

    assign one = 1;

endmodule
```
## Zero [Output zero]
```verilog
module top_module(
    output zero
);
assign zero=0;
endmodule
```
## Wire [Simple wire]
```verilog
module top_module( input in, output out );
assign out=in;
endmodule
```
## Wire4 [four wires]
```verilog
module top_module( 
    input a,b,c,
    output w,x,y,z );
assign w=a,x=b,y=b,z=c;
endmodule
```
## Notgate [Inverter]
```verilog
module top_module( input in, output out );
assign out=~in;
endmodule
```
## Andgate [AND gate]
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
assign out=a&b;
endmodule
```
## Norgate [NOR gate]
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
    assign out=~(a|b);
endmodule
```
## Xnorgate [XNOR gate]
```verilog
module top_module( 
    input a, 
    input b, 
    output out );
    assign out= ~(a^b);
endmodule
```
## Wire decl [Declaring wires]
```verilog
`default_nettype none
module top_module(
    input a,
    input b,
    input c,
    input d,
    output out,
    output out_n   ); 
wire andab,andcd,orout;
    assign andab=a&b,
           andcd=c&d, 
           orout=andab|andcd;
           
    assign out=orout, 
           out_n= ~(orout);
endmodule
```
## 7458 [7458 chip]
```verilog
module top_module ( 
    input p1a, p1b, p1c, p1d, p1e, p1f,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );
wire andp2ab,andp2cd,andp1abc,andp1def;

    assign andp2ab = p2a&p2b, 
           andp2cd = p2c&p2d, 
           p2y= andp2ab|andp2cd;
                     
    assign andp1abc= p1a&p1b&p1c, 
           andp1def= p1d&p1e&p1f,
           p1y= andp1abc|andp1def;

endmodule
```
## Vector0 [Vectors]
```verilog
module top_module ( 
    input wire [2:0] vec,
    output wire [2:0] outv,
    output wire o2,
    output wire o1,
    output wire o0  ); 
    
    assign  outv=vec[2:0];
    
    assign o2=vec[2], 
           o1=vec[1], 
           o0=vec[0]; 
endmodule
```
## Vector1 [Vectors in more detail]
```verilog
module top_module( 
    input wire [15:0] in,
    output wire [7:0] out_hi,
    output wire [7:0] out_lo );
    
    assign out_hi=in[15:8], 
           out_lo=in[7:0];
endmodule

```
## Vector2 [Vector part select]
```verilog
module top_module( 
    input [31:0] in,
    output [31:0] out );

    assign out[31:24] = in[7:0],
           out[23:16] = in[15:8],
           out[15:8] = in[23:16],
           out[7:0] = in[31:24];

endmodule
```
## Vectorgates [Bitwise operators]
```verilog
module top_module( 
    input [2:0] a,
    input [2:0] b,
    output [2:0] out_or_bitwise,
    output out_or_logical,
    output [5:0] out_not
);
    assign out_or_bitwise[2:0]= a[2:0]|b[2:0],
           out_or_logical= a||b,
           out_not[5:3]=~b[2:0],
           out_not[2:0]=~a[2:0];
           
endmodule
```
## Gates4 [4-input gates]
```verilog
module top_module( 
    input [3:0] in,
    output out_and,
    output out_or,
    output out_xor
);
    assign out_and=in[3]&in[2]&in[1]&in[0],
           out_or=in[3]|in[2]|in[1]|in[0],
           out_xor=in[3]^in[2]^in[1]^in[0];
endmodule
```
## Vector3 [Vector concatenation operator]
```verilog
module top_module (
    input [4:0] a, b, c, d, e, f,
    output [7:0] w, x, y, z );//

    wire [31:0] com;
assign com[31:0]={a[4:0],b[4:0],c[4:0],d[4:0],e[4:0],f[4:0],2'b11};
    assign z[7:0]= com[7:0];
    assign y[7:0]= com[15:8];
    assign x[7:0]= com[23:16];
    assign w[7:0]= com[31:24];

endmodule
```
## Vectorr [Vector reversal 1]
```verilog
module top_module( 
    input [7:0] in,
    output [7:0] out
);
    assign out[7:0]={in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};
endmodule
```
method2 (using loop)
```verilog
module top_module( 
    input [7:0] in,
    output [7:0] out
);
  always @(*) begin	
		for (int i=0; i<8; i++)	
			out[i] = in[8-i-1];
	end
endmodule
```
method3 (using generate for-loop)
```verilog
module top_module( 
    input [7:0] in,
    output [7:0] out
);
  generate
		genvar i;
      for (i=0; i<8; i = i+1) begin: rev
			assign out[i] = in[8-i-1];
		end
	endgenerate
endmodule
```
## Vector4 [Replication operator]
```verilog
module top_module (
    input [7:0] in,
    output [31:0] out );

    assign out={{24{in[7]}}, in[7:0]};

endmodule
```
## Vector5 [More replication]
```verilog
module top_module (
    input a, b, c, d, e,
    output [24:0] out );
    
assign out=~{{5{a}},{5{b}},{5{c}},{5{d}},{5{e}}}^{5{a,b,c,d,e}};
    
endmodule
```
## Module [Modules]
```verilog
module top_module ( input a, input b, output out );
    mod_a inst1 (.in1(a), .in2(b), .out(out));
   
    
endmodule
```
## Module pos [Connecting ports by position]
```verilog
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a inst1(out1,out2,a,b,c,d);
endmodule
```
## Module name [Connecting ports by name]
```verilog
module top_module ( 
    input a, 
    input b, 
    input c,
    input d,
    output out1,
    output out2
);
    mod_a inst1(.in1(a), .in2(b), .in3(c), .in4(d), .out1(out1), .out2(out2) );
endmodule
```
## Module shift [Three modules]
```verilog
module top_module ( input clk, input d, output q );
    wire q1,q2;
    my_dff inst1(.clk(clk), .d(d), .q(q1));
    my_dff inst2(.clk(clk), .d(q1), .q(q2));
    my_dff inst3(.clk(clk), .d(q2), .q(q));
endmodule
```
## Module shift8 [Modules and vectors]
```verilog
module top_module ( 
    input clk, 
    input [7:0] d, 
    input [1:0] sel, 
    output [7:0] q 
);
    wire [7:0]q1,q2,q3;
    
    my_dff8 inst1(.clk(clk), .d(d), .q(q1));
    my_dff8 inst2(.clk(clk), .d(q1), .q(q2));
    my_dff8 inst3(.clk(clk), .d(q2), .q(q3));
    
    always @(*)    //this is for combinational block
		case(sel)
			2'h0: q = d;
			2'h1: q = q1;
			2'h2: q = q2;
			2'h3: q = q3;
		endcase

endmodule
```
## Module add [Adder-1]
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire c1,c2;

    add16 inst1(.a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]), .cout(c1));
    add16 inst2(.a(a[31:16]), .b(b[31:16]), .cin(c1), .sum(sum[31:16]), .cout(c2));

endmodule
```
## Module fadd [Adder-2]
```verilog
module top_module (
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire c,c2;
    
    add16 inst1(.a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]),  .cout(c));
    add16 inst2(.a(a[31:16]), .b(b[31:16]), .cin(c), .sum(sum[31:16]),  .cout(c2));
endmodule

module add1 ( input a, input b, input cin,   output sum, output cout );

 assign sum = a ^ b ^ cin;
 assign cout = a&b | a&cin | b&cin;
 
endmodule
```
## Module cseladd [Carry-select adder]
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    output [31:0] sum
);
    wire [15:0]s2,s3,c2,c3,sel;
    
    add16 inst1(.a(a[15:0]), .b(b[15:0]), .cin(1'b0), .sum(sum[15:0]), .cout(sel));
    add16 inst2(.a(a[31:16]), .b(b[31:16]), .cin(1'b0), .sum(s2), .cout(c2));
    add16 inst3(.a(a[31:16]), .b(b[31:16]), .cin(1'b1), .sum(s3), .cout(c3));
    
    always @(*)    
		case(sel)
           1'b0  : sum[31:16] = s2;
           1'b1  : sum[31:16] = s3;
		endcase

endmodule
```
## Module addsub [Adder-subtractor]
```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0]c,c2;
    wire [31:0]xorout,subin;
    
    assign subin={32{sub}};   //making sub 32 bit so that we can XOR it with inp 'b'.
    assign xorout=b^subin;
    
    add16 inst1(.a(a[15:0]), .b(xorout[15:0]), .cin(sub), .cout(c), .sum(sum[15:0]));
    add16 inst2(.a(a[31:16]), .b(xorout[31:16]), .cin(c), .cout(c2), .sum(sum[31:16]));

endmodule
```
method2 (XOR as programmable inverter)

![image](https://user-images.githubusercontent.com/39450902/209582275-f3619c07-8380-4e14-bb1d-aa5c209ef690.png)


```verilog
module top_module(
    input [31:0] a,
    input [31:0] b,
    input sub,
    output [31:0] sum
);
    wire [15:0]c,c2;
    wire [31:0]xorout;
    
    always @(*)                      //XOR gate can also be viewed as a programmable inverter, 
        case(sub)
            0: xorout = b;           //where one input controls whether the other should be inverted
            1: xorout = ~b;
        endcase
    add16 inst1(.a(a[15:0]), .b(xorout[15:0]), .cin(sub), .cout(c), .sum(sum[15:0]));
    add16 inst2(.a(a[31:16]), .b(xorout[31:16]), .cin(c), .cout(c2), .sum(sum[31:16]));

endmodule
```
## Alwaysblock1 [Always block (combinational)]
```verilog
module top_module(
    input a, 
    input b,
    output wire out_assign,
    output reg out_alwaysblock
);
assign out_assign = a & b;
always @(*) out_alwaysblock = a & b;
endmodule
```
## Alwaysblock2 [Always block (clocked)]
```verilog
// synthesis verilog_input_version verilog_2001
module top_module(
    input clk,
    input a,
    input b,
    output wire out_assign,
    output reg out_always_comb,
    output reg out_always_ff   );
assign out_assign = a ^ b;
always @(*) out_always_comb = a ^ b;
    always @(posedge clk) out_always_ff <= a ^ b;
endmodule
```
## Always if [If statement]
```verilog

module top_module(
    input a,
    input b,
    input sel_b1,
    input sel_b2,
    output wire out_assign,
    output reg out_always   );
    
    assign out_assign= sel_b2 ? (sel_b1 ? b : a) : a;
    
    always @(*) begin
        if(sel_b1 && sel_b2) begin
            out_always=b;
        end
        else begin
            out_always=a;
        end
    end
    
endmodule

```
## Always if2 [If statement latches]
```verilog
module top_module (
    input      cpu_overheated,
    output reg shut_off_computer,
    input      arrived,
    input      gas_tank_empty,
    output reg keep_driving  ); //

    always @(*) begin
        shut_off_computer=cpu_overheated; 
    end

    always @(*) begin
        if (~arrived && ~gas_tank_empty) begin
           keep_driving = 1;
          end
         else begin
          keep_driving = 0;
        end
    end

endmodule
```
## Always case [Case statement]
```verilog
module top_module ( 
    input [2:0] sel, 
    input [3:0] data0,
    input [3:0] data1,
    input [3:0] data2,
    input [3:0] data3,
    input [3:0] data4,
    input [3:0] data5,
    output reg [3:0] out   );//

    always@(*) begin  // This is a combinational circuit
        case(sel)
            3'b000 : out=data0;
            3'b001 : out=data1;
            3'b010 : out=data2;
            3'b011 : out=data3;
            3'b100 : out=data4;
            3'b101 : out=data5;
            3'b110 : out=0;
            3'b111 : out=0;
            
        endcase
    end

endmodule
```
## Always case2 [Priority encoder]
```verilog
// synthesis verilog_input_version verilog_2001
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    always @(*)begin
        
        if(in[0]==1)
            pos=0;
        else if(in[1]==1)
            pos=1;
        else if(in[2]==1)
            pos=2; 
        else if(in[3]==1)
            pos=3;
        else pos=0;
    end
endmodule
```
method2 (using loop)
```verilog
module top_module (
    input [3:0] in,
    output reg [1:0] pos  );
    integer i;
       always @(*) begin
           pos=2'b00;
           for(i=3;i>=0;i=i-1)
            if(in[i]==1)
                pos=i;
       end
endmodule
```
## Always casez [Priority encoder with casez]
```verilog
// synthesis verilog_input_version verilog_2001
module top_module (
    input [7:0] in,
    output reg [2:0] pos );
    always @* begin
        casez(in[7:0])
       8'bzzzzzzz1 : pos=0;
       8'bzzzzzz1z : pos=1;
       8'bzzzzz1zz : pos=2;
       8'bzzzz1zzz : pos=3;
       8'bzzz1zzzz : pos=4;
       8'bzz1zzzzz : pos=5;
       8'bz1zzzzzz : pos=6;
       8'b1zzzzzzz : pos=7;
       default : pos=0;
        endcase
    end
endmodule

```
## Always nolatches [Avoiding latches]
```verilog
module top_module (
    input [15:0] scancode,
    output reg left,
    output reg down,
    output reg right,
    output reg up  ); 
   
   always @* begin
    up=0;down=0;right=0;left=0;
      case(scancode)
        16'he06b : left = 1;
        16'he072 : down = 1;
	16'he074 : right = 1;
	16'he075 : up = 1;
      endcase
   end
endmodule
```
## Conditional [Conditional ternary operator]
```verilog
module top_module (
    input [7:0] a, b, c, d,
    output [7:0] min);//
    wire [7:0]abmin,cdmin;

    assign abmin = a>b ? b : a;
    assign cdmin = c>d ? d : c;
    assign min = abmin>cdmin ? cdmin : abmin;
endmodule
```
## Reduction [Reduction operators]
```verilog
module top_module (
    input [7:0] in,
    output parity); 
    assign parity= ^in[7:0];
endmodule
```
## Gates100 [Reduction: Even wider gates]

```verilog
module top_module( 
    input [99:0] in,
    output out_and,
    output out_or,
    output out_xor 
);
    assign out_and = &in[99:0];
    assign out_or = |in[99:0];
    assign out_xor = ^in[99:0];
endmodule
```
## Vector100r [Combinational for-loop: Vector reversal 2]

```verilog
module top_module( 
    input [99:0] in,
    output [99:0] out
);
    integer i;
always @* begin
    for(i=99;i>=0;i=i-1) 
        out[99-i]=in[i];
    end
endmodule
```
## Popcount255 [Combinational for-loop: 255-bit population count]

```verilog
module top_module( 
    input [254:0] in,
    output [7:0] out );
  integer i;
    always @* begin
     out=0;
        for(i=254;i>=0;i=i-1)
         if(in[i]==1) 
           out=out+1;
            else ;
    end
endmodule
```
## Adder100i [Generate for-loop: 100-bit binary adder 2]

```verilog
module top_module( 
    input [99:0] a, b,
    input cin,
    output [99:0] cout,
    output [99:0] sum );

    assign cout[0]= a[0]&b[0] | b[0]&cin | a[0]&cin;
    assign sum[0]= a[0]^b[0]^cin;
   
    integer i;
    always @* begin
        for(i=1;i<100;i++)begin
            sum[i]= a[i]^b[i]^cout[i-1];
            cout[i]= a[i]&b[i] | b[i]&cout[i-1] | a[i]&cout[i-1];
        end
    end
endmodule
```
## Bcdadd100 [Generate for-loop: 100-digit BCD adder]

```verilog

```
## Exams/m2014 q4h [Wire]

```verilog
module top_module (
    input in,
    output out);
    
assign out=in;

endmodule
```
## Exams/m2014 q4i [GND]

```verilog
module top_module (
    output out);
    
assign out=0;

endmodule
```
##  Exams/m2014 q4e [NOR]

```verilog
module top_module (
    input in1,
    input in2,
    output out);
    
    assign out=~(in1|in2);
    
endmodule
```
## Exams/m2014 q4f [Another gate]

```verilog
module top_module (
    input in1,
    input in2,
    output out);
    
assign out=in1&~in2;

endmodule
```
## Exams/m2014 q4g [Two gates]

```verilog
module top_module (
    input in1,
    input in2,
    input in3,
    output out);

    wire xnorout;
    
    assign xnorout = ~(in1 ^ in2);
    assign out = xnorout ^ in3;
    
endmodule
```
## Gates [More logic gates]

```verilog
module top_module( 
    input a, b,
    output out_and,
    output out_or,
    output out_xor,
    output out_nand,
    output out_nor,
    output out_xnor,
    output out_anotb
);
    assign out_and= a & b;
	assign out_or= a | b;
	assign out_xor= a ^ b;
    assign out_nand= ~(a & b);
    assign out_nor= ~(a | b);
    assign out_xnor= ~(a ^ b);
	assign out_anotb= a & ~b;

    
endmodule
```
## 7420 [7420 chip]

```verilog
module top_module ( 
    input p1a, p1b, p1c, p1d,
    output p1y,
    input p2a, p2b, p2c, p2d,
    output p2y );

    assign p1y = ~(p1a & p1b & p1c & p1d);
    assign p2y = ~(p2a & p2b & p2c & p2d);

endmodule
```
## Truthtable1 [Truth tables]

```verilog
module top_module( 
    input x3,
    input x2,
    input x1,  // three inputs
    output f   // one output
);
 
    assign f=(~x3 & x2 & ~x1) | (~x3 & x2 & x1) | (x3 & ~x2 & x1) | (x3 & x2 & x1);
    
endmodule
```
## Mt2015 eq2 [Two-bit equality]

```verilog
module top_module ( input [1:0] A, input [1:0] B, output z ); 
    always @* begin
        if(A==B)
            z=1;
    else z=0;
    end
endmodule
```
## Mt2015 q4a [Simple circuit A]

```verilog
module top_module (input x, input y, output z);
    assign z = (x^y) & x;
endmodule
```
## Mt2015 q4b [Simple circuit B]

```verilog
module top_module ( input x, input y, output z );
    assign z = ~(x ^ y);
endmodule
```
## Mt2015 q4 [Combine circuits A and B]

```verilog
module top_module (input x, input y, output z);
wire z1,z2,z3,z4,zor,zand;
    moda inst1(x,y,z1);
    moda inst2(x,y,z2);
    modb inst3(x,y,z3);
    modb inst4(x,y,z4);
    
    assign zor= z1 | z2;
    assign zand = z3 & z4;
    assign z= zor ^ zand;
    
endmodule
   module moda (input x, input y, output z);
    assign z = (x^y) & x;
endmodule

    module modb ( input x, input y, output z );
    assign z = ~(x ^ y);
endmodule
```
## Ringer [Ring or vibrate]

```verilog
module top_module (
    input ring,
    input vibrate_mode,
    output ringer,       // Make sound
    output motor         // Vibrate
);
	assign ringer = ring & ~vibrate_mode;
    assign motor = ring & vibrate_mode;
endmodule
```
## Thermostat

```verilog
module top_module (
    input too_cold,
    input too_hot,
    input mode,
    input fan_on,
    output heater,
    output aircon,
    output fan
); 
    assign heater = mode & too_cold ;
    assign aircon = ~mode & too_hot ;
    assign fan = aircon | heater | fan_on;
        
endmodule
```
## Popcount3 [3-bit population count]

```verilog
module top_module( 
    input [2:0] in,
    output [1:0] out );
    
    integer i;
    always @* begin
        out=0;
        for(i=2;i>=0;i=i-1)
            if(in[i]==1)
                out=out+1;
        else ;
    end
endmodule
```
## Gatesv [Gates and vectors]

```verilog
module top_module( 
    input [3:0] in,
    output [2:0] out_both,
    output [3:1] out_any,
    output [3:0] out_different );
    
    assign out_both = in[2:0] & in[3:1] ;
    assign out_any = in[3:1] | in[2:0];
    assign out_different = in[3:0] ^ {in[0], in[3:1]};
endmodule
```
## Gatesv100 [Even longer vectors]

```verilog
module top_module( 
    input [99:0] in,
    output [98:0] out_both,
    output [99:1] out_any,
    output [99:0] out_different );
    
    assign out_both = in[98:0] & in[99:1];
    assign out_any = in[99:1] | in[98:0];
    assign out_different = in[99:0] ^ {in[0], in[99:1]};
endmodule
```
## Mux2to1 [2-to-1 multiplexer]

```verilog
module top_module( 
    input a, b, sel,
    output out ); 
assign out= sel ? b : a;
endmodule
```
## Mux2to1v [2-to-1 bus multiplexer]
```verilog
module top_module( 
    input [99:0] a, b,
    input sel,
    output [99:0] out );
assign out= sel ? b : a;
endmodule
```
## Mux9to1 [9-to-1 multiplexer]
```verilog
module top_module( 
    input [15:0] a, b, c, d, e, f, g, h, i,
    input [3:0] sel,
    output [15:0] out );

    always @* begin
        case(sel)
            4'b0000   : out = a ;
            4'b0001    : out = b;
            4'b0010   : out = c;
            4'b0011   : out = d;
            4'b0100    : out = e;
            4'b0101    : out = f;
            4'b0110    : out = g;
            4'b0111   : out = h;
            4'b1000    : out = i;
            default : out = {16{1'b1}};
        endcase
    end
        
endmodule
```
## Mux256to1 [256-to-1 multiplexer]

```verilog
module top_module( 
    input [255:0] in,
    input [7:0] sel,
    output out );
    
    assign out= in[sel];
    
endmodule
```
## Mux256to1v [256-to-1 4-bit multiplexer]

```verilog
module top_module( 
    input [1023:0] in,
    input [7:0] sel,
    output [3:0] out );

  assign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};
endmodule
```
## Hadd [Half adder]

```verilog

```
